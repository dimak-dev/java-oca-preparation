= Garbage Collection
:toc:
:toc-title: Содержание
:toclevels: 3

== Назначение

Тема "Garbage Collection" является важной частью экзамена OCA Java SE 8 и критична для понимания управления памятью в Java.
Знание принципов сборки мусора, понимание когда объекты становятся доступными для удаления, и особенности финализации объектов необходимо для написания эффективного Java кода.
Эта тема помогает понять автоматическое управление памятью в Java и избежать утечек памяти в приложениях.

== Теория

=== Основы сборки мусора

Сборка мусора (Garbage Collection, GC) - это автоматический процесс управления памятью в Java, который освобождает память, занятую объектами, которые больше не используются программой.

**Ключевые принципы:**

* Автоматическое управление памятью - программист не управляет освобождением памяти напрямую
* Объекты создаются в куче (heap) и автоматически удаляются, когда становятся недоступными
* GC запускается JVM автоматически, когда это необходимо
* Программист не может точно контролировать, когда произойдет сборка мусора

=== Eligibility для сборки мусора

Объект становится eligible (подходящим) для сборки мусора, когда на него больше нет доступных ссылок из активной части программы.

**Основные случаи:**

* **Nulling references** - присваивание null всем ссылкам на объект
* **Reassigning references** - переназначение ссылки на другой объект
* **Out of scope** - переменная выходит за границы области видимости
* **Island of isolation** - группа объектов ссылается друг на друга, но извне недоступна

**Пример eligibility:**
[source,java]
----
String str = new String("Hello");  // Объект создан
str = null;                        // Объект eligible для GC
----

=== Финализация объектов

Финализация - это процесс выполнения метода `finalize()` перед удалением объекта сборщиком мусора.

**Особенности finalize():**

* Вызывается автоматически перед сборкой мусора (если переопределен)
* Нет гарантии, что будет вызван или когда именно
* Может быть вызван только один раз для объекта
* Может замедлить процесс сборки мусора
* Считается устаревшим подходом в современной Java

**Правила finalize():**

* Сигнатура: `protected void finalize() throws Throwable`
* Не должен полагаться на порядок финализации
* Исключения в finalize() игнорируются
* Объект может "воскреснуть" в finalize(), присвоив ссылку на себя

=== System.gc() и Runtime.gc()

Программист может запросить сборку мусора, но не может её принудительно вызвать.

**Методы запроса GC:**

* `System.gc()` - статический метод для запроса сборки мусора
* `Runtime.getRuntime().gc()` - эквивалентный вызов через Runtime
* Это только запрос (hint), JVM может проигнорировать его
* Не гарантирует немедленное освобождение памяти

=== Мониторинг памяти

Java предоставляет способы мониторинга состояния памяти.

**Основные методы:**

* `Runtime.getRuntime().totalMemory()` - общий размер кучи
* `Runtime.getRuntime().freeMemory()` - доступная память в куче
* `Runtime.getRuntime().maxMemory()` - максимальный размер кучи

== Примеры кода

=== Пример 1: Eligibility объектов для сборки мусора

Класс `GCEligibilityDemo` демонстрирует различные случаи, когда объекты становятся eligible для GC:

[source,java]
----
include::../../src/com/ru/oca/gc/GCEligibilityDemo.java[]
----

**Ключевые аспекты:**

* Демонстрация nulling references
* Показ reassigning references
* Пример out of scope ситуаций
* Создание island of isolation

=== Пример 2: Работа с методом finalize()

Класс `FinalizationDemo` показывает особенности работы метода finalize():

[source,java]
----
include::../../src/com/ru/oca/gc/FinalizationDemo.java[]
----

**Ключевые аспекты:**

* Переопределение метода finalize()
* Демонстрация непредсказуемости вызова finalize()
* Показ возможности "воскрешения" объекта
* Объяснение проблем с финализацией

=== Пример 3: Мониторинг памяти и System.gc()

Класс `MemoryMonitoringDemo` демонстрирует мониторинг памяти и запрос GC:

[source,java]
----
include::../../src/com/ru/oca/gc/MemoryMonitoringDemo.java[]
----

**Ключевые аспекты:**

* Мониторинг состояния памяти через Runtime
* Демонстрация System.gc() как запроса, а не команды
* Измерение эффективности сборки мусора
* Практические рекомендации по работе с памятью

== Примеры вопросов

=== Вопрос 1
Когда объект становится eligible для сборки мусора?

* A) Когда на него нет доступных ссылок из активной части программы
* B) Сразу после вызова System.gc() ❌ НЕВЕРНО
* C) Когда вызывается его метод finalize() ❌ НЕВЕРНО
* D) Когда программа завершается ❌ НЕВЕРНО

*Правильный ответ:* A

*Объяснение:* Объект eligible для GC, когда на него нет достижимых ссылок из выполняющейся программы. System.gc() только запрашивает сборку мусора, но не гарантирует её.

=== Вопрос 2
Что можно сказать о методе finalize()?

* A) Гарантированно вызывается перед удалением объекта ❌ НЕВЕРНО
* B) Может быть вызван максимум один раз для объекта
* C) Всегда вызывается в определенном порядке ❌ НЕВЕРНО
* D) Является обязательным для переопределения ❌ НЕВЕРНО

*Правильный ответ:* B

*Объяснение:* Метод finalize() может быть вызван максимум один раз для объекта. Нет гарантии, что он будет вызван вообще, нет определенного порядка вызовов, и он не обязателен для переопределения.

=== Вопрос 3
Что делает вызов System.gc()?

* A) Немедленно запускает сборку мусора ❌ НЕВЕРНО
* B) Принудительно удаляет все недоступные объекты ❌ НЕВЕРНО
* C) Запрашивает у JVM выполнить сборку мусора
* D) Очищает всю память приложения ❌ НЕВЕРНО

*Правильный ответ:* C

*Объяснение:* System.gc() только запрашивает (делает hint) у JVM выполнить сборку мусора. JVM может проигнорировать этот запрос. Это не принудительная команда.

== Типичные ошибки

=== Ошибка 1: Полагаться на немедленную сборку мусора после System.gc()

**Проблема:** Ожидание, что System.gc() немедленно освободит память:
[source,java]
----
Object obj = new Object();
obj = null;
System.gc();
// Ошибочное предположение, что память уже освобождена
----

**Решение:** Понимать, что System.gc() - это только запрос:
[source,java]
----
Object obj = new Object();
obj = null;
System.gc(); // Только запрос, не команда
// Не полагаться на немедленное освобождение памяти
----

=== Ошибка 2: Использование finalize() для критических операций

**Проблема:** Полагаться на finalize() для важных операций очистки:
[source,java]
----
class FileHandler {
    private FileInputStream file;

    protected void finalize() throws Throwable {
        file.close(); // ПЛОХО! Может не вызваться
    }
}
----

**Решение:** Использовать try-with-resources или явные методы очистки:
[source,java]
----
class FileHandler implements AutoCloseable {
    private FileInputStream file;

    public void close() throws IOException {
        if (file != null) {
            file.close(); // Явная очистка
        }
    }
}
----

=== Ошибка 3: Создание циклических ссылок и забывание обнулить их

**Проблема:** Создание циклических ссылок, которые не становятся eligible для GC:
[source,java]
----
class Parent {
    Child child;
}
class Child {
    Parent parent;
}
// Циклическая ссылка - объекты могут не удалиться
----

**Решение:** Использовать слабые ссылки или явно обнулять ссылки:
[source,java]
----
// Явно разрывать циклические ссылки
parent.child = null;
child.parent = null;
parent = null;
child = null;
----

=== Ошибка 4: Неправильное понимание области видимости локальных переменных

**Проблема:** Думать, что объект eligible для GC, когда переменная выходит из области видимости:
[source,java]
----
{
    Object obj = new Object();
} // obj вышел из области видимости, но может быть еще не eligible
----

**Решение:** Понимать разницу между областью видимости переменной и доступностью объекта для GC.

== Связанные API

* **System.gc()** - запрос сборки мусора
* **Runtime.getRuntime()** - получение информации о среде выполнения
* **Runtime.totalMemory()** - общий размер доступной памяти
* **Runtime.freeMemory()** - размер свободной памяти
* **Runtime.maxMemory()** - максимальный размер памяти
* **Object.finalize()** - метод финализации (deprecated)
* **WeakReference** - слабые ссылки для предотвращения утечек памяти

== Связанные темы

* xref:../java-basics/index.adoc[Java Basics]
* xref:../oo-concepts/index.adoc[OO Concepts]
* xref:../java-data-types/index.adoc[Working with Java Data Types]
* xref:../constructors/index.adoc[Constructors]
* xref:../methods/index.adoc[Working with Methods]
