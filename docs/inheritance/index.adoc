= Working with Inheritance
:toc:
:toc-title: Содержание
:toclevels: 3

== Назначение

Тема "Working with Inheritance" является фундаментальной для экзамена OCA и покрывает механизм наследования в Java.
Понимание наследования классов, доступа к членам родительского класса, переопределения методов и использования ключевого слова `super` критически важно для объектно-ориентированного программирования.
Наследование позволяет создавать иерархии классов, повторно использовать код и реализовывать полиморфизм - один из основных принципов ООП.

== Теория

=== Концепция наследования

Наследование - это механизм, позволяющий одному классу (дочернему или производному) наследовать поля и методы другого класса (родительского или базового).
В Java используется ключевое слово `extends` для создания наследования.

**Синтаксис:**
[source,java]
----
class ChildClass extends ParentClass {
    // Дополнительные поля и методы
}
----

**Основные принципы:**

* Дочерний класс получает все non-private поля и методы родительского класса
* Java поддерживает только одиночное наследование (класс может наследовать только от одного класса)
* Все классы в Java неявно наследуют от класса `Object`
* Конструкторы не наследуются, но могут вызываться через `super()`

=== Модификаторы доступа в наследовании

При наследовании важно понимать, какие члены родительского класса доступны в дочернем классе:

* **`public`** - доступны везде, включая дочерние классы
* **`protected`** - доступны в том же пакете и в дочерних классах (даже в других пакетах)
* **package-private (без модификатора)** - доступны только в том же пакете
* **`private`** - недоступны в дочерних классах

**Пример:**
[source,java]
----
class Parent {
    public String publicField;      // Доступно в дочернем классе
    protected String protectedField; // Доступно в дочернем классе
    String packageField;            // Доступно если в том же пакете
    private String privateField;    // НЕ доступно в дочернем классе
}
----

=== Переопределение методов (Method Overriding)

Переопределение позволяет дочернему классу предоставить специфичную реализацию метода, который уже определен в родительском классе.

**Правила переопределения:**

* Метод должен иметь такую же сигнатуру (имя, параметры)
* Возвращаемый тип должен быть тем же или ковариантным
* Модификатор доступа не может быть более ограничительным
* Нельзя переопределять `static`, `final` или `private` методы
* Рекомендуется использовать аннотацию `@Override`

**Пример:**
[source,java]
----
class Animal {
    public void makeSound() {
        System.out.println("Животное издает звук");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Гав-гав!");
    }
}
----

=== Ключевое слово super

Ключевое слово `super` используется для обращения к элементам родительского класса:

**1. Вызов конструктора родительского класса:**
[source,java]
----
class Child extends Parent {
    public Child() {
        super(); // Вызов конструктора родительского класса
    }
}
----

**2. Вызов метода родительского класса:**
[source,java]
----
@Override
public void method() {
    super.method(); // Вызов метода родительского класса
    // Дополнительная логика
}
----

**3. Доступ к полю родительского класса:**
[source,java]
----
super.fieldName // Доступ к полю родительского класса
----

**Важные правила для super():**

* `super()` должен быть первым оператором в конструкторе
* Если явно не вызвать `super()`, компилятор добавляет `super()` автоматически
* Если в родительском классе нет конструктора по умолчанию, необходимо явно вызвать подходящий конструктор

=== Порядок инициализации при наследовании

При создании объекта дочернего класса выполняется следующий порядок:

. Инициализация статических полей и блоков родительского класса
. Инициализация статических полей и блоков дочернего класса
. Инициализация полей экземпляра родительского класса
. Выполнение конструктора родительского класса
. Инициализация полей экземпляра дочернего класса
. Выполнение конструктора дочернего класса

=== Полиморфизм через наследование

Наследование обеспечивает полиморфизм - способность объектов разных классов реагировать на одни и те же вызовы методов:

[source,java]
----
Animal[] animals = {
    new Dog("Рекс"),
    new Cat("Мурка")
};

for (Animal animal : animals) {
    animal.makeSound(); // Вызовется соответствующий переопределенный метод
}
----

=== Ограничения наследования

**Что нельзя переопределить:**

* `private` методы (они невидимы в дочернем классе)
* `static` методы (можно скрыть, но не переопределить)
* `final` методы (помечены как неизменяемые)
* Конструкторы (не наследуются)

**Что нельзя наследовать:**

* `private` члены класса
* Конструкторы
* Статические блоки инициализации

== Примеры кода

=== Пример 1: Полная демонстрация наследования

Класс `InheritanceDemo` демонстрирует все аспекты наследования в Java:

[source,java]
----
include::../../src/com/ru/oca/inheritance/InheritanceDemo.java[]
----

**Ключевые аспекты:**

* Базовое наследование с использованием `extends`
* Переопределение методов с аннотацией `@Override`
* Использование `super()` в конструкторах
* Вызов методов родительского класса через `super.method()`
* Доступ к `protected` полям родительского класса
* Многоуровневая иерархия наследования
* Полиморфное поведение объектов разных классов

== Примеры вопросов

=== Вопрос 1
Что будет выведено следующим кодом?
[source,java]
----
class Parent {
    public Parent() { System.out.print("Parent "); }
}
class Child extends Parent {
    public Child() { System.out.print("Child "); }
}
Child c = new Child();
----

* A) Parent Child ✓ ПРАВИЛЬНО
* B) Child Parent ❌ НЕВЕРНО
* C) Child ❌ НЕВЕРНО
* D) Parent ❌ НЕВЕРНО

*Правильный ответ:* A
*Объяснение:* Сначала выполняется конструктор родительского класса (автоматически вызывается super()), затем дочернего.

=== Вопрос 2
Какой метод будет вызван при выполнении `animal.makeSound()`?
[source,java]
----
Animal animal = new Dog();
animal.makeSound();
----
где Dog переопределяет метод makeSound() из Animal.

* A) Метод из класса Animal ❌ НЕВЕРНО
* B) Метод из класса Dog ✓ ПРАВИЛЬНО
* C) Ошибка компиляции ❌ НЕВЕРНО
* D) Ошибка времени выполнения ❌ НЕВЕРНО

*Правильный ответ:* B
*Объяснение:* Используется полиморфизм - вызывается переопределенный метод из фактического типа объекта (Dog), не из типа ссылки.

=== Вопрос 3
Какие поля класса Parent доступны в классе Child?
[source,java]
----
class Parent {
    public int a = 1;
    protected int b = 2;
    int c = 3;              // package-private
    private int d = 4;
}
class Child extends Parent { }
----

* A) Только a ❌ НЕВЕРНО
* B) a и b ❌ НЕВЕРНО
* C) a, b и c (если в том же пакете) ✓ ПРАВИЛЬНО
* D) Все поля ❌ НЕВЕРНО

*Правильный ответ:* C
*Объяснение:* private поля недоступны в дочерних классах, package-private доступны только в том же пакете.

== Типичные ошибки

=== Ошибка 1: Забывание вызова super() в конструкторе

**Проблема:** Родительский класс имеет только параметризованный конструктор, а дочерний не вызывает super().
[source,java]
----
class Parent {
    public Parent(String name) { }
}
class Child extends Parent {
    public Child() { } // Ошибка компиляции - нет super()
}
----

**Решение:** Явно вызывать подходящий конструктор родительского класса: `super("name");`

=== Ошибка 2: Попытка переопределить private методы

**Проблема:** Попытка переопределить private метод в дочернем классе.
[source,java]
----
class Parent {
    private void method() { }
}
class Child extends Parent {
    @Override  // Ошибка - private метод не переопределяется
    private void method() { }
}
----

**Решение:** private методы недоступны для переопределения. Это будет новый метод, а не переопределение.

=== Ошибка 3: Ослабление модификатора доступа при переопределении

**Проблема:** Попытка сделать переопределенный метод менее доступным.
[source,java]
----
class Parent {
    public void method() { }
}
class Child extends Parent {
    @Override
    protected void method() { } // Ошибка компиляции
}
----

**Решение:** Модификатор доступа может только расширяться: protected -> public, но не наоборот.

== Связанные API

* `Object` класс - корневой класс для всех классов в Java
* `Class.getSuperclass()` - получение родительского класса
* `instanceof` оператор - проверка принадлежности к иерархии классов

== Связанные темы

* xref:../oo-concepts/index.adoc[OO Concepts]
* xref:../java-data-types/index.adoc[Working with Java Data Types]
* xref:../constructors/index.adoc[Constructors]
* xref:../methods/index.adoc[Working with Methods]
