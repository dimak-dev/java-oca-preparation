= Method Overloading
:toc:
:toc-title: Содержание
:toclevels: 3

== Назначение

Тема "Method Overloading" является важной частью экзамена OCA и покрывает концепцию перегрузки методов в Java.
Понимание правил перегрузки методов, механизма выбора подходящего метода компилятором и отличий от переопределения методов критически важно для написания эффективного кода.
Перегрузка методов позволяет создавать несколько версий одного метода с различными параметрами, что улучшает читаемость и удобство использования API.

== Теория

=== Что такое перегрузка методов

Перегрузка методов (Method Overloading) - это возможность определения нескольких методов с одинаковым именем, но с различными параметрами в одном классе.
Компилятор определяет, какой именно метод вызвать, основываясь на типах, количестве и порядке аргументов.

**Ключевые характеристики:**

* Методы должны иметь одинаковое имя
* Параметры должны различаться по типу, количеству или порядку
* Возвращаемый тип может быть любым (не влияет на перегрузку)
* Происходит статическое связывание (compile-time binding)

=== Способы перегрузки методов

**1. По типу параметров:**
[source,java]
----
public void print(int value) { }
public void print(String value) { }
public void print(double value) { }
----

**2. По количеству параметров:**
[source,java]
----
public int add(int a, int b) { }
public int add(int a, int b, int c) { }
public int add(int a, int b, int c, int d) { }
----

**3. По порядку параметров:**
[source,java]
----
public void process(String name, int age) { }
public void process(int age, String name) { }
----

=== Автоматическое приведение типов

При выборе перегруженного метода компилятор может выполнять автоматическое приведение типов:

**Порядок приоритета приведения:**

. Точное совпадение типов
. Автоматическое расширение примитивных типов (byte → short → int → long → float → double)
. Автоупаковка/распаковка (int ↔ Integer)
. Varargs (переменное количество аргументов)

**Пример приведения:**
[source,java]
----
public void method(int x) { }     // Приоритет 1
public void method(long x) { }    // Приоритет 2
public void method(Integer x) { } // Приоритет 3

method(5);  // Вызовет method(int x)
----

=== Перегрузка конструкторов

Конструкторы также могут быть перегружены:

[source,java]
----
public class Student {
    public Student() { }
    public Student(String name) { }
    public Student(String name, int age) { }
    public Student(String name, int age, String major) { }
}
----

**Цепочка конструкторов:**

* Использование `this()` для вызова другого конструктора
* Вызов `this()` должен быть первой строкой в конструкторе

=== Varargs в перегрузке

Varargs (переменное количество аргументов) влияют на выбор метода:

[source,java]
----
public void method(int x) { }           // Приоритет выше
public void method(int... x) { }        // Приоритет ниже

method(5);      // Вызовет method(int x)
method(5, 6);   // Вызовет method(int... x)
----

=== Неоднозначность в перегрузке

Некоторые ситуации могут привести к неоднозначности:

[source,java]
----
public void method(int a, double b) { }
public void method(double a, int b) { }

// method(1, 2); // Ошибка компиляции: неоднозначность
----

=== Отличия от переопределения

**Перегрузка (Overloading):**

* Одинаковое имя метода, разные параметры
* В одном классе
* Статическое связывание (compile-time)
* Может изменять возвращаемый тип

**Переопределение (Overriding):**

* Одинаковые имя и параметры метода
* В иерархии классов (родитель-потомок)
* Динамическое связывание (runtime)
* Тот же возвращаемый тип (или ковариантный)

== Примеры кода

=== Пример 1: Полная демонстрация перегрузки методов

Класс `MethodOverloadingDemo` демонстрирует все аспекты перегрузки методов:

[source,java]
----
include::../../src/com/ru/oca/methodoverloading/MethodOverloadingDemo.java[]
----

**Ключевые аспекты:**

* Базовая перегрузка по типам параметров
* Перегрузка по количеству и порядку параметров
* Автоматическое приведение типов при выборе метода
* Использование varargs в перегрузке
* Перегрузка конструкторов с цепочкой вызовов
* Примеры неоднозначности и способы их избежания

== Примеры вопросов

=== Вопрос 1
Какие из следующих методов могут существовать в одном классе одновременно?
[source,java]
----
public void method(int x) { }
public void method(Integer x) { }
public int method(int x) { }
public void method(int y) { }
----

* A) Только первый и второй ✓ ПРАВИЛЬНО
* B) Все четыре ❌ НЕВЕРНО
* C) Только первый и третий ❌ НЕВЕРНО
* D) Только второй и четвертый ❌ НЕВЕРНО

*Правильный ответ:* A
*Объяснение:* Перегрузка основана на параметрах, не на возвращаемом типе. Третий метод отличается только возвращаемым типом, четвертый - только именем параметра.

=== Вопрос 2
Какой метод будет вызван для `method(5)`?
[source,java]
----
public void method(int x) { }        // 1
public void method(long x) { }       // 2
public void method(Integer x) { }    // 3
public void method(int... x) { }     // 4
----

* A) Метод 2 ❌ НЕВЕРНО
* B) Метод 1 ✓ ПРАВИЛЬНО
* C) Метод 3 ❌ НЕВЕРНО
* D) Метод 4 ❌ НЕВЕРНО

*Правильный ответ:* B
*Объяснение:* Точное совпадение типов имеет наивысший приоритет. int литерал точно соответствует параметру int.

=== Вопрос 3
Что произойдет при компиляции этого кода?
[source,java]
----
public void process(int a, double b) { }
public void process(double a, int b) { }
...
process(1, 2);
----

* A) Вызовется первый метод ❌ НЕВЕРНО
* B) Вызовется второй метод ❌ НЕВЕРНО
* C) Ошибка компиляции ✓ ПРАВИЛЬНО
* D) Выберется случайно ❌ НЕВЕРНО

*Правильный ответ:* C
*Объяснение:* Неоднозначность - компилятор не может определить, какой метод выбрать, поскольку оба требуют одинакового приведения типов.

== Типичные ошибки

=== Ошибка 1: Путаница между перегрузкой и переопределением

**Проблема:** Попытка "перегрузить" метод в дочернем классе с теми же параметрами.
[source,java]
----
class Parent {
    public void method(int x) { }
}
class Child extends Parent {
    public void method(int x) { } // Это переопределение, не перегрузка
}
----

**Решение:** Понимать различия - перегрузка в одном классе, переопределение в иерархии.

=== Ошибка 2: Изменение только возвращаемого типа

**Проблема:** Попытка создать перегруженный метод, изменив только возвращаемый тип.
[source,java]
----
public void method(int x) { }
public int method(int x) { } // Ошибка компиляции
----

**Решение:** Перегрузка должна отличаться параметрами, возвращаемый тип не учитывается.

=== Ошибка 3: Неожиданное поведение с автоупаковкой

**Проблема:** Неправильное ожидание какой метод будет вызван.
[source,java]
----
public void method(int x) { }
public void method(Integer x) { }
method(5); // Вызовет int версию, не Integer
----

**Решение:** Помнить о приоритетах: точное совпадение выше автоупаковки.

== Связанные API

* Методы классов-оберток (`Integer.valueOf()`, `Double.parseDouble()`)
* Конструкторы стандартных классов (перегружены в большинстве случаев)
* `StringBuilder` - множество перегруженных методов `append()`

== Связанные темы

* xref:../oo-concepts/index.adoc[OO Concepts]
* xref:../java-data-types/index.adoc[Working with Java Data Types]
* xref:../constructors/index.adoc[Constructors]
* xref:../methods/index.adoc[Working with Methods]
