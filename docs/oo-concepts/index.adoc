= OO Concepts
:toc:
:toc-title: Содержание
:toclevels: 3

== Назначение

Объектно-ориентированные концепции (OO Concepts) являются центральной темой экзамена OCA Java SE 8 и фундаментом языка Java.
Понимание принципов инкапсуляции, наследования, полиморфизма и абстракции критически важно для разработки эффективных Java-приложений.
Эта тема охватывает основы создания классов, объектов, интерфейсов и их взаимодействие в объектно-ориентированной парадигме.

== Теория

=== Инкапсуляция (Encapsulation)

Инкапсуляция - это механизм сокрытия внутренних деталей реализации класса и предоставления контролируемого доступа к данным через публичные методы.

**Принципы инкапсуляции:**

* Поля класса объявляются как `private`
* Доступ к полям предоставляется через `getter` и `setter` методы
* Валидация данных выполняется в методах-аксессорах
* Внутренняя реализация может изменяться без влияния на внешний код

**Пример:**
[source,java]
----
public class BankAccount {
    private double balance; // Скрытое поле

    public double getBalance() { // Контролируемый доступ
        return balance;
    }

    public void deposit(double amount) { // Валидация в методе
        if (amount > 0) {
            balance += amount;
        }
    }
}
----

=== Наследование (Inheritance)

Наследование позволяет создавать новые классы на основе существующих, наследуя их поля и методы.
Java поддерживает только одиночное наследование классов (один родитель), но множественное наследование интерфейсов.

**Ключевые концепции:**

* Ключевое слово `extends` для наследования классов
* Родительский класс (superclass) и дочерний класс (subclass)
* Ключевое слово `super` для обращения к родительскому классу
* Переопределение методов с аннотацией `@Override`
* Все классы неявно наследуются от `Object`

**Пример:**
[source,java]
----
public class Animal {
    protected String name;

    public void eat() {
        System.out.println(name + " is eating");
    }
}

public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println(name + " is eating dog food");
    }

    public void bark() {
        System.out.println(name + " is barking");
    }
}
----

=== Полиморфизм (Polymorphism)

Полиморфизм позволяет объектам разных классов обрабатываться единообразно через общий интерфейс или родительский класс.

**Виды полиморфизма:**

* **Полиморфизм времени компиляции** - перегрузка методов (method overloading)
* **Полиморфизм времени выполнения** - переопределение методов (method overriding)

**Динамическое связывание:**

* Реальный метод выбирается во время выполнения
* Основывается на типе объекта, а не типе ссылки
* Позволяет писать более гибкий и расширяемый код

=== Абстракция (Abstraction)

Абстракция скрывает сложные детали реализации и предоставляет упрощенный интерфейс для работы с объектами.

**Механизмы абстракции:**

* **Абстрактные классы** - классы с ключевым словом `abstract`
* **Интерфейсы** - контракты, определяющие поведение классов
* **Абстрактные методы** - методы без реализации

**Правила абстрактных классов:**

* Нельзя создать экземпляр абстрактного класса
* Могут содержать как абстрактные, так и конкретные методы
* Наследники должны реализовать все абстрактные методы

=== Интерфейсы (Interfaces)

Интерфейсы определяют контракт поведения без предоставления реализации (до Java 8).

**Характеристики интерфейсов:**

* Все методы по умолчанию `public abstract` (до Java 8)
* Все поля по умолчанию `public static final`
* Класс может реализовывать множество интерфейсов
* Интерфейс может наследовать другие интерфейсы

== Примеры кода

=== Пример 1: Демонстрация инкапсуляции

[source,java]
----
include::../../src/com/ru/oca/ooconcepts/EncapsulationDemo.java[]
----

**Ключевые аспекты:**

* Private поля для сокрытия данных
* Public методы для контролируемого доступа
* Валидация входных данных в setter методах
* Защита целостности объекта

=== Пример 2: Наследование и полиморфизм

[source,java]
----
include::../../src/com/ru/oca/ooconcepts/InheritanceDemo.java[]
----

**Ключевые аспекты:**

* Использование extends для наследования
* Переопределение методов с @Override
* Полиморфное поведение объектов
* Вызов методов родительского класса через super

=== Пример 3: Абстракция и интерфейсы

[source,java]
----
include::../../src/com/ru/oca/ooconcepts/AbstractionDemo.java[]
----

**Ключевые аспекты:**

* Определение абстрактных классов и методов
* Создание и реализация интерфейсов
* Множественная реализация интерфейсов
* Использование абстракции для создания гибкой архитектуры

== Примеры вопросов

=== Вопрос 1
Что из перечисленного является правильным примером инкапсуляции в Java?

* A) Объявление всех полей класса как `private` и предоставление `public` методов доступа
* B) Объявление всех полей класса как `public` ❌ НЕВЕРНО
* C) Использование только `static` методы в классе ❌ НЕВЕРНО
* D) Объявление класса как `abstract` ❌ НЕВЕРНО

*Правильный ответ:* A

*Объяснение:* Инкапсуляция предполагает сокрытие внутренних данных (private поля) и предоставление контролируемого доступа через public методы.

=== Вопрос 2
Что произойдет при выполнении следующего кода?

[source,java]
----
abstract class Animal {
    public abstract void makeSound();
}

public class Test {
    public static void main(String[] args) {
        Animal animal = new Animal();
    }
}
----

* A) Код скомпилируется и выполнится успешно ❌ НЕВЕРНО
* B) Ошибка компиляции: нельзя создать экземпляр абстрактного класса
* C) Ошибка выполнения: AbstractInstantiationError ❌ НЕВЕРНО
* D) Код скомпилируется, но ничего не произойдет ❌ НЕВЕРНО

*Правильный ответ:* B

*Объяснение:* Абстрактные классы не могут быть инстанциированы. Компилятор выдаст ошибку "Animal is abstract; cannot be instantiated".

=== Вопрос 3
Какой результат будет выведен при выполнении кода?

[source,java]
----
class Parent {
    public void method() {
        System.out.println("Parent method");
    }
}

class Child extends Parent {
    public void method() {
        System.out.println("Child method");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.method();
    }
}
----

* A) Parent method ❌ НЕВЕРНО
* B) Child method ❌ НЕВЕРНО
* C) Child method
* D) Ошибка компиляции ❌ НЕВЕРНО

*Правильный ответ:* C

*Объяснение:* Благодаря полиморфизму вызывается метод того класса, экземпляр которого был создан (Child), а не тип ссылки (Parent).

== Типичные ошибки

=== Ошибка 1: Нарушение инкапсуляции через public поля

**Проблема:** Объявление полей как `public`, что нарушает принцип инкапсуляции:
[source,java]
----
public class BadExample {
    public String name; // Плохо - прямой доступ
    public int age;     // Нет контроля валидации
}
----

**Решение:** Использовать private поля с getter/setter методами:
[source,java]
----
public class GoodExample {
    private String name;
    private int age;

    public String getName() { return name; }
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;
        }
    }

    public int getAge() { return age; }
    public void setAge(int age) {
        if (age >= 0 && age <= 150) {
            this.age = age;
        }
    }
}
----

=== Ошибка 2: Попытка создания экземпляра абстрактного класса

**Проблема:** Попытка инстанциировать абстрактный класс или интерфейс:
[source,java]
----
abstract class Shape {
    abstract void draw();
}

// Ошибка компиляции!
Shape shape = new Shape();
----

**Решение:** Создавать экземпляры конкретных реализаций:
[source,java]
----
class Circle extends Shape {
    void draw() { System.out.println("Drawing circle"); }
}

Shape shape = new Circle(); // Правильно
----

=== Ошибка 3: Неправильное переопределение методов

**Проблема:** Попытка переопределить метод с изменением сигнатуры:
[source,java]
----
class Parent {
    public void method(String s) { }
}

class Child extends Parent {
    // Это перегрузка, а не переопределение!
    public void method(int i) { }
}
----

**Решение:** Использовать точно такую же сигнатуру с аннотацией @Override:
[source,java]
----
class Child extends Parent {
    @Override
    public void method(String s) {
        // Правильное переопределение
    }
}
----

=== Ошибка 4: Путаница между IS-A и HAS-A отношениями

**Проблема:** Использование наследования вместо композиции:
[source,java]
----
// Неправильно - Car не является Engine
class Car extends Engine { }
----

**Решение:** Использовать композицию для HAS-A отношений:
[source,java]
----
// Правильно - Car имеет Engine
class Car {
    private Engine engine;
}
----

== Связанные API

* **java.lang.Object** - базовый класс для всех объектов, методы equals(), hashCode(), toString()
* **instanceof** - оператор проверки типа во время выполнения
* **getClass()** - получение информации о классе объекта
* **super** - ключевое слово для доступа к родительскому классу
* **@Override** - аннотация для переопределения методов
* **Comparable<T>** - интерфейс для сравнения объектов
* **Cloneable** - маркерный интерфейс для клонирования объектов

== Связанные темы

* xref:../java-basics/index.adoc[Java Basics]
* xref:../inheritance/index.adoc[Working with Inheritance]
* xref:../instanceof/index.adoc[instanceof Operator]
* xref:../constructors/index.adoc[Constructors]
* xref:../methods/index.adoc[Working with Methods]
* xref:../method-overloading/index.adoc[Method Overloading]
