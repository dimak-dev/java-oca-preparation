= Working with Java Data Types
:toc:
:toc-title: Содержание
:toclevels: 3

== Назначение

Тема "Working with Java Data Types" является критически важной для экзамена OCA Java SE 8 и основополагающей для понимания работы Java.
Правильное понимание различий между примитивными и ссылочными типами, механизмов автоупаковки и распаковки, а также правил приведения типов необходимо для написания корректного Java кода.
Эта тема охватывает фундаментальные концепции хранения данных в памяти и их обработки виртуальной машиной Java.

== Теория

=== Примитивные типы данных

Java поддерживает восемь примитивных типов данных, которые хранят значения непосредственно в стеке:

**Целочисленные типы:**

* `byte` - 8 бит, диапазон: -128 до 127
* `short` - 16 бит, диапазон: -32,768 до 32,767
* `int` - 32 бита, диапазон: -2,147,483,648 до 2,147,483,647
* `long` - 64 бита, диапазон: -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807

**Типы с плавающей точкой:**

* `float` - 32 бита, приблизительная точность ~7 десятичных цифр
* `double` - 64 бита, приблизительная точность ~15 десятичных цифр

**Другие типы:**

* `char` - 16 бит, представляет символ Unicode (0 до 65,535)
* `boolean` - логический тип, может быть `true` или `false`

=== Ссылочные типы

Ссылочные типы (Reference Types) включают классы, интерфейсы, массивы и enum. В отличие от примитивных типов:

* Хранят ссылку (адрес) на объект в куче
* По умолчанию инициализируются значением `null`
* Наследуются от `Object`
* Поддерживают методы `equals()`, `hashCode()`, `toString()`

**Основные ссылочные типы:**

* `String` - неизменяемые строки
* `Object` - базовый класс для всех объектов
* Массивы всех типов
* Пользовательские классы

=== Автоупаковка и распаковка (Boxing/Unboxing)

Java автоматически преобразует между примитивными типами и их объектными аналогами (wrapper классами).

**Wrapper классы:**

* `Byte`, `Short`, `Integer`, `Long`
* `Float`, `Double`
* `Character`, `Boolean`

**Автоупаковка (Autoboxing):** примитив → wrapper объект
**Распаковка (Unboxing):** wrapper объект → примитив

[source,java]
----
Integer i = 10;        // Автоупаковка int → Integer
int j = i;             // Распаковка Integer → int
----

=== Приведение типов (Type Casting)

**Неявное приведение (Widening):** автоматическое преобразование в больший тип
* `byte` → `short` → `int` → `long` → `float` → `double`
* `char` → `int`

**Явное приведение (Narrowing):** требует явного указания типа, может привести к потере данных
* `double` → `float` → `long` → `int` → `short` → `byte`
* `int` → `char`

[source,java]
----
int i = 10;
long l = i;          // Неявное приведение
int j = (int) l;     // Явное приведение
----

=== Особенности работы с типами

**Диапазоны и переполнение:**

* При переполнении происходит "wrap around" - возврат к минимальному значению
* Операции с `float` и `double` могут давать `Infinity` и `NaN`

**Сравнение:**

* Примитивы сравниваются по значению (`==`)
* Объекты сравниваются по ссылке (`==`) или по содержимому (`equals()`)

== Примеры кода

=== Пример 1: Работа с примитивными типами

Класс `PrimitiveTypesDemo` демонстрирует основные примитивные типы и их характеристики:

[source,java]
----
include::../../src/com/ru/oca/datatypes/PrimitiveTypesDemo.java[]
----

**Ключевые аспекты:**

* Объявление и инициализация всех примитивных типов
* Демонстрация диапазонов значений
* Примеры переполнения и поведения при выходе за границы
* Особенности работы с литералами

=== Пример 2: Автоупаковка и распаковка

Класс `BoxingUnboxingDemo` показывает механизмы автоматического преобразования:

[source,java]
----
include::../../src/com/ru/oca/datatypes/BoxingUnboxingDemo.java[]
----

**Ключевые аспекты:**

* Автоматическая упаковка примитивов в wrapper объекты
* Автоматическая распаковка wrapper объектов в примитивы
* Кеширование малых значений Integer
* Опасности NullPointerException при распаковке null

=== Пример 3: Приведение типов и их особенности

Класс `TypeCastingDemo` демонстрирует различные виды приведения типов:

[source,java]
----
include::../../src/com/ru/oca/datatypes/TypeCastingDemo.java[]
----

**Ключевые аспекты:**

* Неявное и явное приведение типов
* Потеря точности при сужающих преобразованиях
* Переполнение при приведении типов
* Приведение типов для char

== Примеры вопросов

=== Вопрос 1
Что будет результатом выполнения следующего кода?

[source,java]
----
int i = 128;
byte b = (byte) i;
System.out.println(b);
----

* A) 128 ❌ НЕВЕРНО
* B) -128
* C) Ошибка компиляции ❌ НЕВЕРНО
* D) 0 ❌ НЕВЕРНО

*Правильный ответ:* B

*Объяснение:* При приведении int 128 к byte происходит переполнение, так как максимальное значение byte равно 127. Результат: 128 - 256 = -128.

=== Вопрос 2
Какой результат будет выведен при выполнении кода?

[source,java]
----
Integer a = 100;
Integer b = 100;
Integer c = 200;
Integer d = 200;
System.out.println((a == b) + " " + (c == d));
----

* A) true false ❌ НЕВЕРНО
* B) false false ❌ НЕВЕРНО
* C) true true
* D) false true ❌ НЕВЕРНО

*Правильный ответ:* C

*Объяснение:* Java кеширует Integer объекты для значений от -128 до 127. Поэтому a == b возвращает true (один объект), а c == d возвращает false (разные объекты).

=== Вопрос 3
Что произойдет при выполнении следующего кода?

[source,java]
----
Double d = null;
double primitive = d;
System.out.println(primitive);
----

* A) Выведет null ❌ НЕВЕРНО
* B) Выведет 0.0 ❌ НЕВЕРНО
* C) NullPointerException
* D) Ошибка компиляции ❌ НЕВЕРНО

*Правильный ответ:* C

*Объяснение:* При попытке распаковки (unboxing) null значения wrapper класса в примитивный тип возникает NullPointerException во время выполнения.

== Типичные ошибки

=== Ошибка 1: Путаница в сравнении wrapper объектов

**Проблема:** Использование `==` для сравнения wrapper объектов вместо `equals()`:
[source,java]
----
Integer a = 200;
Integer b = 200;
if (a == b) { // ОШИБКА! Сравнивает ссылки, не значения
    System.out.println("Equal");
}
----

**Решение:** Используйте `equals()` для сравнения значений wrapper объектов:
[source,java]
----
Integer a = 200;
Integer b = 200;
if (a.equals(b)) { // ПРАВИЛЬНО
    System.out.println("Equal");
}
----

=== Ошибка 2: NullPointerException при автораспаковке

**Проблема:** Попытка использовать null wrapper объект как примитив:
[source,java]
----
Integer count = null;
int total = count + 10; // ОШИБКА! NullPointerException
----

**Решение:** Всегда проверяйте на null перед использованием:
[source,java]
----
Integer count = null;
int total = (count != null ? count : 0) + 10; // ПРАВИЛЬНО
----

=== Ошибка 3: Неожиданное переполнение при приведении типов

**Проблема:** Игнорирование возможности переполнения при сужающем приведении:
[source,java]
----
int big = 300;
byte small = (byte) big; // small будет 44, а не 300!
----

**Решение:** Проверяйте диапазоны перед приведением или используйте методы проверки:
[source,java]
----
int big = 300;
if (big >= Byte.MIN_VALUE && big <= Byte.MAX_VALUE) {
    byte small = (byte) big;
} else {
    // Обработка переполнения
}
----

=== Ошибка 4: Некорректная работа с float литералами

**Проблема:** Попытка присвоить double литерал переменной float без суффикса:
[source,java]
----
float f = 3.14; // ОШИБКА КОМПИЛЯЦИИ! 3.14 это double
----

**Решение:** Используйте суффикс f или явное приведение:
[source,java]
----
float f1 = 3.14f;        // ПРАВИЛЬНО - суффикс f
float f2 = (float) 3.14; // ПРАВИЛЬНО - явное приведение
----

== Связанные API

* **Wrapper классы** - Integer.valueOf(), Double.parseDouble(), Boolean.parseBoolean()
* **Math класс** - методы для математических операций с числами
* **Character класс** - методы для работы с символами (isDigit(), isLetter(), toUpperCase())
* **Number класс** - базовый класс для всех числовых wrapper классов
* **System.out** - методы print(), println() для вывода различных типов данных
* **String.valueOf()** - преобразование примитивов в строки

== Связанные темы

* xref:../java-basics/index.adoc[Java Basics]
* xref:../operators/index.adoc[Using Operators and Decision Constructs]
* xref:../string-stringbuilder/index.adoc[Working with Java API - String, StringBuilder]
* xref:../methods/index.adoc[Working with Methods]
